<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.10">
  <POU Name="FBCylTronicCylinder" Id="{065cd091-3563-4a4f-b586-4eea2d97404e}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FBCylTronicCylinder
VAR_INPUT
	DataIn AT %I* : CyltronicProcessDataIn;
	rEingabe_Sollposition:REAL;
	stAxisName:STRING;
	bManual :BOOL;
	bUP :BOOL;
	bDOWN:BOOL;
END_VAR
VAR_OUTPUT
	DataOut AT %Q* : CyltronicProcessDataOut;
END_VAR
VAR
	ActualForce:REAL;
	ActualPosition:REAL;
	ActualSpeed:REAL;
	LimitSwitchIn:BOOL;
	LimitSwitchOut:BOOL;
	MotionCommandCompleted:BOOL;
	MotionModeActive:BOOL;
	Ready:BOOL;
	WarningActive:BOOL;
	TrackingErrorToleranceExceeded:BOOL;
	CylState:REAL;
	Position_Aktiv:BOOL;
	Sinus_Aktiv:BOOL;
	BNP_Aktiv:BOOL;
	StateText, Meldung : STRING;
	State, NextState : INT;
	Start, Reset, In, Out, Acknowledge, ForceActive, SpeedActive, AccelerationActive, TimeActive : BOOL;
	Pos, Speed, Acceleration, Force, Time0, Distance, AccTime, DecTime, SpeedTime : REAL;
	iTrig, oTrig : R_TRIG;
	Q:BOOL:=TRUE;
	//ConfiguredSpeed 		: REAL := 235.294118;
	//ConfiguredAcceleration 	: REAL := 20;
	//ConfiguredDeceleration 	: REAL := 20; 
	//ConfiguredForce 		: REAL := 176.470588;
	MinPos 					: REAL := 0; 
	MaxPos 					: REAL := 150;
	isPos, targetPos, targetSpeed, targetAcceleration, targetForce : REAL;
	// mMode : CyltronicMotionMode;
	//NormalAcceleration: REAL := 10;
	//NormalSpeed: REAL := 300;
	//NormalForce: REAL := 20;
	Achse:Antrieb:=Antrieb.Off;
	trigUP:r_TRIG;
	trigDown:r_TRIG;
END_VAR]]></Declaration>
    <Implementation>
      <ST><![CDATA[//Allgemeiner Teil mit individuellem Teil gemischt

//Allgemeine Eingabe 
trigUP(clk:=bUP); 
trigDown(clk:=bDOWN);
DataOut.CyltronicDataOutAct.SpeedOverride:=gvl.Speed;
DataOut.CyltronicDataOutAct.ForceOverride:=gvl.Force;
DataOut.CyltronicDataOutAct.AccelerationOverride:=gvl.Acceleration;

//Sollposition Eingabe
IF trigUP.Q AND bManual THEN
	IF rEingabe_Sollposition < 199 THEN
		rEingabe_Sollposition:=rEingabe_Sollposition+gvl.n;
	ELSE
		rEingabe_Sollposition:=200;
	END_IF
ELSIF trigDown.Q AND bManual THEN
	IF rEingabe_Sollposition > 1 THEN
		rEingabe_Sollposition:=rEingabe_Sollposition-gvl.n;
	ELSE
		rEingabe_Sollposition:=0;
	END_IF
END_IF

//Bei Steigungswinkel wieder auf Homing Position
IF GVL.BndP  THEN
	achse:=Antrieb.Homing;
END_IF

//Ausschaltbedingungen (Prio 1)
IF NOT gvl.V48VDC_Einbefehl OR NOT gvl.NOTAUS THEN
	Achse:=Antrieb.Off;
	gvl.V48VDC_Einbefehl:=FALSE;
	bManual:=FALSE;
END_IF

//Resetbefehl
IF gvl.reset THEN
	dataout.CyltronicDataOutAct.MotionMode:=255;
	Achse:=Antrieb.Off;
	gvl.V48VDC_Einbefehl:=FALSE;
END_IF

CASE Achse OF
	Antrieb.Off:
	GVL.Achsenkontrolle:=FALSE;
	Position_Aktiv:=FALSE;
	//Ausschalten der Achse
	IF gvl.NOTAUS THEN
		DataOut.CyltronicDataOutAct.TargetPosition:=0;
		IF DataIn.CyltronicDataInAct.LimitSwitchIn THEN
			DataOut.CyltronicDataOutAct.MotionMode:=0;
		END_IF
	END_IF
		
	//Nächster Zustand (Einschaltbefehl)
	IF gvl.V48Einbefehl AND gvl.V48VDC_Einbefehl THEN
		//Lernfahrt beim Einschalten
		DataOut.CyltronicDataOutAct.MotionMode:=2;
		IF DataIn.CyltronicDataInAct.LimitSwitchIn THEN
			DataOut.CyltronicDataOutAct.MotionMode:=6;
			Achse:=Antrieb.Homing;
		END_IF
	END_IF
	
	Antrieb.Homing:
	//Beim Einschalten das Homing für die Grundposition
	gvl.eingabesperre:=TRUE;
	BNP_Aktiv:=FALSE;
	Sinus_Aktiv:=FALSE;
	gvl.Achsenkontrolle:=FALSE;
	Position_Aktiv:=FALSE;
	IF gvl.Automatik THEN
		//Sobald der Zylinder Ready ist wird die Grundposition (Homingposition) welche vordefiniert wrude eingenommen
		IF DataIn.CyltronicDataInAct.Ready AND DataIn.CyltronicDataInAct.Homed  THEN
			DataOut.CyltronicDataOutAct.MotionMode:=6;
			DataOut.CyltronicDataOutAct.TargetPosition:=gvl.Eingabe_Grundposition;
			//Sobald die Positionierung stattgefunden hat, wird der Zustand Positionierung freigeschaltet
			IF to_int(DataIn.CyltronicDataInAct.ActualPosition) = to_int(gvl.Eingabe_Grundposition) THEN
				Achse:=Antrieb.Position;
				gvl.eingabesperre:=FALSE;
			END_IF
		END_IF
	END_IF
			
	Antrieb.Position:
	//Eingabe für eine eingegebene Sollposition
	Position_Aktiv:=TRUE;
	
	
	IF gvl.Automatik THEN
		DataOut.CyltronicDataOutAct.MotionMode:=6;
		//Eingabe Sollposition --> Istposition anfahren
		DataOut.CyltronicDataOutAct.TargetPosition:=rEingabe_Sollposition;
	END_IF
	
	//Aktivierung Ball on Plate
	IF gvl.BndP THEN
		Achse:=Antrieb.BallundPlate;
		Position_Aktiv:=FALSE;
	END_IF
	
	//Aktivierung Sinus
	IF gvl.Sinus THEN
		Achse:=Antrieb.Sinus;
		Position_Aktiv:=FALSE;
	END_IF
	
	//Aktivierung von Achsenbewegung
	IF gvl.Achsenkontrolle THEN
		Achse:=Antrieb.Achse;
		Position_Aktiv:=FALSE;
	END_IF
	
	//Homingbefehl
	IF gvl.Homing THEN
		Achse:=Antrieb.Homing;
		Position_Aktiv:=FALSE;
	END_IF
	
	Antrieb.Achse:
	//Achsenbewegung
	DataOut.CyltronicDataOutAct.MotionMode:=6;
	dataout.CyltronicDataOutAct.TargetPosition:=rEingabe_Sollposition;
	
	IF gvl.Homing THEN
		gvl.Achsenkontrolle:=FALSE;
		Achse:=Antrieb.Homing;
		bManual:=FALSE;
	END_IF
	
	IF gvl.Grundposition THEN
		gvl.Achsenkontrolle:=FALSE;
		Achse:=Antrieb.Position;
		bManual:=FALSE;
	END_IF
	
	Antrieb.Sinus:
	//Sinus-Wellenbewegung
	IF Achse=Antrieb.Sinus THEN
		Sinus_Aktiv:=TRUE;
	ELSE
		Sinus_Aktiv:=FALSE;
	END_IF
	
	IF DataIn.CyltronicDataInAct.ActualPosition<199 AND Q THEN
		DataOut.CyltronicDataOutAct.TargetPosition:=DataOut.CyltronicDataOutAct.TargetPosition+1;
	ELSIF DataIn.CyltronicDataInAct.ActualPosition>2 THEN
		Q:=FALSE;
		DataOut.CyltronicDataOutAct.TargetPosition:=DataOut.CyltronicDataOutAct.TargetPosition-1;
	ELSE
		Q:=TRUE;
	END_IF
	
	//Homingbefehl
	IF gvl.Homing THEN
		Sinus_Aktiv:=FALSE;
		Achse:=Antrieb.Homing;
	END_IF
	
	IF gvl.Grundposition THEN
		Sinus_Aktiv:=FALSE;
		Achse:=Antrieb.Position;
	END_IF
	
	
	Antrieb.BallundPlate: //für spätere Zwecke oder wenn noch zeit
	//Code für die Ball and Plate
	IF Achse=Antrieb.BallundPlate THEN
		BNP_Aktiv:=TRUE;
	ELSE
		BNP_Aktiv:=FALSE;
	END_IF
		
	
	//Homingbefehl
	IF gvl.Homing THEN
		Achse:=Antrieb.Homing;
		BNP_Aktiv:=FALSE;
	END_IF
	
	IF gvl.Grundposition THEN
		BNP_Aktiv:=FALSE;
		Achse:=Antrieb.Position;
	END_IF
END_CASE

//Outputs
ActualForce:=DataIn.CyltronicDataInAct.ActualForce;
ActualPosition:=DataIn.CyltronicDataInAct.ActualPosition;
ActualSpeed:=DataIn.CyltronicDataInAct.ActualSpeed;
LimitSwitchIn:=DataIn.CyltronicDataInAct.LimitSwitchIn;
LimitSwitchOut:=DataIn.CyltronicDataInAct.LimitSwitchOut;
MotionCommandCompleted:=DataIn.CyltronicDataInAct.MotionCommandCompleted;
MotionModeActive:=DataIn.CyltronicDataInAct.MotionModeActive;
Ready:=DataIn.CyltronicDataInAct.Ready;
WarningActive:=DataIn.CyltronicDataInAct.WarningActive;
TrackingErrorToleranceExceeded:=DataIn.CyltronicDataInAct.TrackingErrorToleranceExceeded;
CylState:=DataIn.CyltronicDataInAct.State;]]></ST>
    </Implementation>
    <LineIds Name="FBCylTronicCylinder">
      <LineId Id="4957" Count="197" />
      <LineId Id="260" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>