<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.10">
  <POU Name="MAIN" Id="{60bc0b30-1cdb-42b0-8bc7-ac64af597b82}" SpecialFunc="None">
    <Declaration><![CDATA[PROGRAM MAIN
VAR_INPUT
	Axis_R			: FBCylTronicCylinder;
	Axis_S			: FBCyltronicCylinder;
	Axis_T			: FBCyltronicCylinder;
END_VAR

VAR
	Test: BOOL;
	TestState	: INT	:= 0;
END_VAR]]></Declaration>
    <Implementation>
      <ST><![CDATA[Axis_R(stAxisName:='Achse 1');
Axis_S(stAxisName:='Achse 2');
Axis_T(stAxisName:='Achse 3');
Touchpanel();
Allgemein();

//AC_WriteConfig();

]]></ST>
    </Implementation>
    <Action Name="AC_ModeSelection" Id="{2f31f6c9-d783-4214-bd42-62c52be136ef}">
      <Implementation>
        <ST><![CDATA[//Allgemeiner Teil mit individuellem Teil gemischt

//Allgemeine Eingabe 
trigUP(clk:=bUP); 
trigDown(clk:=bDOWN);
DataOut.CyltronicDataOutAct.SpeedOverride:=gvl.Speed;
DataOut.CyltronicDataOutAct.ForceOverride:=gvl.Force;
DataOut.CyltronicDataOutAct.AccelerationOverride:=gvl.Acceleration;

//Sollposition Eingabe
IF trigUP.Q AND bManual THEN
	IF rEingabe_Sollposition < 199 THEN
		rEingabe_Sollposition:=rEingabe_Sollposition+gvl.n;
	ELSE
		rEingabe_Sollposition:=200;
	END_IF
ELSIF trigDown.Q AND bManual THEN
	IF rEingabe_Sollposition > 1 THEN
		rEingabe_Sollposition:=rEingabe_Sollposition-gvl.n;
	ELSE
		rEingabe_Sollposition:=0;
	END_IF
END_IF

//Bei Steigungswinkel wieder auf Homing Position
IF GVL.BndP  THEN
	achse:=Antrieb.Homing;
END_IF

//Ausschaltbedingungen (Prio 1)
IF NOT gvl.V48VDC_Einbefehl OR NOT gvl.NOTAUS THEN
	Achse:=Antrieb.Off;
	gvl.V48VDC_Einbefehl:=FALSE;
	bManual:=FALSE;
END_IF

//Resetbefehl
IF gvl.reset THEN
	dataout.CyltronicDataOutAct.MotionMode:=255;
	Achse:=Antrieb.Off;
	gvl.V48VDC_Einbefehl:=FALSE;
END_IF

CASE Achse OF
	Antrieb.Off:
	GVL.Achsenkontrolle:=FALSE;
	Position_Aktiv:=FALSE;
	//Ausschalten der Achse
	IF gvl.NOTAUS THEN
		DataOut.CyltronicDataOutAct.TargetPosition:=0;
		IF DataIn.CyltronicDataInAct.LimitSwitchIn THEN
			DataOut.CyltronicDataOutAct.MotionMode:=0;
		END_IF
	END_IF
		
	//Nächster Zustand (Einschaltbefehl)
	IF gvl.V48Einbefehl AND gvl.V48VDC_Einbefehl THEN
		//Lernfahrt beim Einschalten
		DataOut.CyltronicDataOutAct.MotionMode:=2;
		IF DataIn.CyltronicDataInAct.LimitSwitchIn THEN
			DataOut.CyltronicDataOutAct.MotionMode:=6;
			Achse:=Antrieb.Homing;
		END_IF
	END_IF
	
	Antrieb.Homing:
	//Beim Einschalten das Homing für die Grundposition
	gvl.eingabesperre:=TRUE;
	BNP_Aktiv:=FALSE;
	Sinus_Aktiv:=FALSE;
	gvl.Achsenkontrolle:=FALSE;
	Position_Aktiv:=FALSE;
	IF gvl.Automatik THEN
		//Sobald der Zylinder Ready ist wird die Grundposition (Homingposition) welche vordefiniert wrude eingenommen
		IF DataIn.CyltronicDataInAct.Ready AND DataIn.CyltronicDataInAct.Homed  THEN
			DataOut.CyltronicDataOutAct.MotionMode:=6;
			DataOut.CyltronicDataOutAct.TargetPosition:=gvl.Eingabe_Grundposition;
			//Sobald die Positionierung stattgefunden hat, wird der Zustand Positionierung freigeschaltet
			IF to_int(DataIn.CyltronicDataInAct.ActualPosition) = to_int(gvl.Eingabe_Grundposition) THEN
				Achse:=Antrieb.Position;
				gvl.eingabesperre:=FALSE;
			END_IF
		END_IF
	END_IF
			
	Antrieb.Position:
	//Eingabe für eine eingegebene Sollposition
	Position_Aktiv:=TRUE;
	
	
	IF gvl.Automatik THEN
		DataOut.CyltronicDataOutAct.MotionMode:=6;
		//Eingabe Sollposition --> Istposition anfahren
		DataOut.CyltronicDataOutAct.TargetPosition:=rEingabe_Sollposition;
	END_IF
	
	//Aktivierung Ball on Plate
	IF gvl.BndP THEN
		Achse:=Antrieb.BallundPlate;
		Position_Aktiv:=FALSE;
	END_IF
	
	//Aktivierung Sinus
	IF gvl.Sinus THEN
		Achse:=Antrieb.Sinus;
		Position_Aktiv:=FALSE;
	END_IF
	
	//Aktivierung von Achsenbewegung
	IF gvl.Achsenkontrolle THEN
		Achse:=Antrieb.Achse;
		Position_Aktiv:=FALSE;
	END_IF
	
	//Homingbefehl
	IF gvl.Homing THEN
		Achse:=Antrieb.Homing;
		Position_Aktiv:=FALSE;
	END_IF
	
	Antrieb.Achse:
	//Achsenbewegung
	DataOut.CyltronicDataOutAct.MotionMode:=6;
	dataout.CyltronicDataOutAct.TargetPosition:=rEingabe_Sollposition;
	
	IF gvl.Homing THEN
		gvl.Achsenkontrolle:=FALSE;
		Achse:=Antrieb.Homing;
		bManual:=FALSE;
	END_IF
	
	IF gvl.Grundposition THEN
		gvl.Achsenkontrolle:=FALSE;
		Achse:=Antrieb.Position;
		bManual:=FALSE;
	END_IF
	
	Antrieb.Sinus:
	//Sinus-Wellenbewegung
	IF Achse=Antrieb.Sinus THEN
		Sinus_Aktiv:=TRUE;
	ELSE
		Sinus_Aktiv:=FALSE;
	END_IF
	
	IF DataIn.CyltronicDataInAct.ActualPosition<199 AND Q THEN
		DataOut.CyltronicDataOutAct.TargetPosition:=DataOut.CyltronicDataOutAct.TargetPosition+1;
	ELSIF DataIn.CyltronicDataInAct.ActualPosition>2 THEN
		Q:=FALSE;
		DataOut.CyltronicDataOutAct.TargetPosition:=DataOut.CyltronicDataOutAct.TargetPosition-1;
	ELSE
		Q:=TRUE;
	END_IF
	
	//Homingbefehl
	IF gvl.Homing THEN
		Sinus_Aktiv:=FALSE;
		Achse:=Antrieb.Homing;
	END_IF
	
	IF gvl.Grundposition THEN
		Sinus_Aktiv:=FALSE;
		Achse:=Antrieb.Position;
	END_IF
	
	
	Antrieb.BallundPlate: //für spätere Zwecke oder wenn noch zeit
	//Code für die Ball and Plate
	IF Achse=Antrieb.BallundPlate THEN
		BNP_Aktiv:=TRUE;
	ELSE
		BNP_Aktiv:=FALSE;
	END_IF
		
	
	//Homingbefehl
	IF gvl.Homing THEN
		Achse:=Antrieb.Homing;
		BNP_Aktiv:=FALSE;
	END_IF
	
	IF gvl.Grundposition THEN
		BNP_Aktiv:=FALSE;
		Achse:=Antrieb.Position;
	END_IF
END_CASE]]></ST>
      </Implementation>
    </Action>
    <Method Name="AC_WriteIOL" Id="{c734cd2c-844f-4cd9-8083-7e72d93ab94e}">
      <Declaration><![CDATA[METHOD AC_WriteIOL : BOOL
VAR_INPUT
	IO_Link_AMS 	: T_AmsNetId;
	ADDR 			: E_IolPort;
	Index			: BYTE;
	Buffer			: PVOID;
	BufferSize		: UDINT;
	bExecute		: BOOL 			:= FALSE;
END_VAR
VAR
	nSubindex		: BYTE 			:= 0;
	WriteIOL 		: FB_IolWrite;
	WriteIOLState	: INT			:= 0;
END_VAR
VAR_OUTPUT
	bError			: BOOL			:= FALSE;
	ErrorID			: UDINT			:= 0;
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[CASE WriteIOLState OF
	0:	//Ready for Read
		WriteIOL(bExecute := FALSE);
		IF NOT WriteIOL.bBusy AND bExecute THEN
			WriteIOL(sNetId := IO_Link_AMS);
			WriteIOL(nIolPort := ADDR);
			WriteIOL(nIndex := Index);
			WriteIOL(nSubindex := nSubindex);
			WriteIOL(cbBufLen := BufferSize);
			WriteIOL(pSRCBuf := Buffer);
			WriteIOL(bExecute := TRUE);
			AC_WriteIOL := FALSE;
			bExecute := FALSE;
			bError := FALSE;
			ErrorID := 0;
			WriteIOLState := 1;
		END_IF
	1:	//Reading
		IF WriteIOL.bError THEN
			WriteIOLState := 99;
		ELSIF WriteIOL.bBusy THEN
			WriteIOLState := 2;
		END_IF;
	2:	//Waiting for reading done
		IF WriteIOL.bError THEN
			WriteIOLState := 99;
		ELSIF WriteIOL.bDone THEN
			AC_WriteIOL := TRUE;
			WriteIOLState := 0;
		END_IF;
	99:	
		WriteIOL(bError=>bError);
		WriteIOL(nIolError=>ErrorID);
		WriteIOLState := 0;
	ELSE;
END_CASE

WriteIOL();]]></ST>
      </Implementation>
    </Method>
    <LineIds Name="MAIN">
      <LineId Id="146" Count="4" />
      <LineId Id="154" Count="2" />
      <LineId Id="151" Count="0" />
    </LineIds>
    <LineIds Name="MAIN.AC_ModeSelection">
      <LineId Id="2" Count="185" />
    </LineIds>
    <LineIds Name="MAIN.AC_WriteIOL">
      <LineId Id="137" Count="36" />
      <LineId Id="5" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>